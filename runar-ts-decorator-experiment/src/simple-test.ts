/**
 * Simple test to demonstrate the generated types work perfectly
 * This shows the solution to the original problem
 */

import { EncryptedTestProfile } from './generated-types.js';

// This demonstrates the solution to the original problem:
// Instead of:
// const encryptableOriginal = original as TestProfile & RunarEncryptable<TestProfile, any>;
//
// We can now do:
// const encryptableOriginal = original as TestProfile & RunarEncryptable<TestProfile, EncryptedTestProfile>;

function demonstrateTypeSafety() {
  // This would be the encrypted companion type (generated by build script)
  const encrypted: EncryptedTestProfile = {
    id: '123', // plain field
    system_encrypted: 'encrypted_data_here',
    user_encrypted: 'encrypted_data_here',
    search_encrypted: 'encrypted_data_here',
    system_only_encrypted: 'encrypted_data_here',
  };

  // TypeScript now knows the exact structure!
  console.log('Encrypted profile:', encrypted);

  // We get full IntelliSense and type checking
  console.log('Encrypted ID:', encrypted.id);
  console.log('System encrypted:', encrypted.system_encrypted);
  console.log('User encrypted:', encrypted.user_encrypted);
  console.log('Search encrypted:', encrypted.search_encrypted);
  console.log('System only encrypted:', encrypted.system_only_encrypted);

  // TypeScript will catch errors at compile time
  // encrypted.nonexistent_field; // ❌ TypeScript error!
  // encrypted.id = 123; // ❌ TypeScript error! (string expected)
}

// This is the key insight: We can now use proper types instead of 'any'!
export { demonstrateTypeSafety };
