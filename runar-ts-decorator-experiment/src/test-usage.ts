/**
 * Test file to demonstrate the generated types in action
 * This shows how we can use proper types instead of 'any'
 */

import { TestProfile } from './test-class.js';
import { EncryptedTestProfile } from './generated-types.js';

// Now we can use proper types instead of 'any'!
function demonstrateTypeSafety() {
  // Create a test profile
  const profile = new TestProfile(
    '123',
    'Test User',
    'secret123',
    'test@example.com',
    'system_data'
  );

  // This would be the encrypted companion type (generated by build script)
  const encrypted: EncryptedTestProfile = {
    id: '123', // plain field
    system_encrypted: 'encrypted_data_here',
    user_encrypted: 'encrypted_data_here',
    search_encrypted: 'encrypted_data_here',
    system_only_encrypted: 'encrypted_data_here',
  };

  // TypeScript now knows the exact structure!
  console.log('Plain profile:', profile);
  console.log('Encrypted profile:', encrypted);

  // We get full IntelliSense and type checking
  console.log('Profile ID:', profile.id);
  console.log('Encrypted ID:', encrypted.id);
  console.log('System encrypted:', encrypted.system_encrypted);
  console.log('User encrypted:', encrypted.user_encrypted);
  console.log('Search encrypted:', encrypted.search_encrypted);
  console.log('System only encrypted:', encrypted.system_only_encrypted);

  // TypeScript will catch errors at compile time
  // encrypted.nonexistent_field; // ❌ TypeScript error!
  // encrypted.id = 123; // ❌ TypeScript error! (string expected)
}

// This demonstrates the solution to the original problem:
// Instead of:
// const encryptableOriginal = original as TestProfile & RunarEncryptable<TestProfile, any>;
//
// We can now do:
// const encryptableOriginal = original as TestProfile & RunarEncryptable<TestProfile, EncryptedTestProfile>;

export { demonstrateTypeSafety };
