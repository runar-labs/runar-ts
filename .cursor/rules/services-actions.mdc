---
description: When creating or modifying services, actions or event handlers using the runar framework  in JS or TS. When writting tests for services, action and event using the runar framework in JS or TS
alwaysApply: false
---
## Core Rules
### 1. No Fallbacks - Single Path Execution
- **❌ WRONG**: Try one type, fallback to another
- **✅ CORRECT**: Expect exact type, fail if mismatch

```typescript
// ❌ BAD - Fallback pattern
const stringResult = req.payload.as<string>();
if (!stringResult.ok) {
  const bytesResult = req.payload.as<Uint8Array>();
  if (bytesResult.ok) {
    label = new TextDecoder().decode(bytesResult.value);
  }
}

// ✅ GOOD - Single path, clear expectations
const stringResult = req.payload.as<string>();
if (!stringResult.ok) {
  return err('Expected string payload for label');
}
const label = stringResult.value;
```

### 2. Action Handler Signature
```typescript
type ActionHandler = (
  payload: AnyValue,
  context: RequestContext
) => Promise<Result<AnyValue, string>>;
```

### 3. Never Use `unknown` Types
```typescript
// ❌ BAD
const result = payload.as<unknown>();

// ✅ GOOD
const result = payload.as<string>();
const result = payload.as<MyStruct>();
```

## Framework Responsibilities

### Framework Handles:
- Serialization/Deserialization (CBOR conversion)
- Encryption/Decryption (remote calls)
- Network Transport (local vs remote routing)
- Request ID Management (internal concern)
- Type Safety (runtime type checking)

### Action Handlers Do:
- Business Logic Only (pure functions)
- Type Checking (`AnyValue.as<T>()`)
- Error Handling (`Result<AnyValue, string>`)
- Simple Returns (`AnyValue` results)

## Anti-Patterns (NEVER DO)

### 1. Fallback Logic
```typescript
// ❌ NEVER DO THIS
const stringResult = payload.as<string>();
if (stringResult.ok) {
  return ok(AnyValue.from(stringResult.value));
} else {
  const bytesResult = payload.as<Uint8Array>();
  if (bytesResult.ok) {
    return ok(AnyValue.from(new TextDecoder().decode(bytesResult.value)));
  }
}
```

### 2. Manual Serialization
```typescript
// ❌ NEVER DO THIS
const input = AnyValue.fromBytes(req.payload); // Framework handles this
return { ok: true, payload: result.serialize() }; // Framework handles this
```

### 3. Request ID Handling
```typescript
// ❌ NEVER DO THIS
return {
  ok: true,
  requestId: req.requestId, // Internal concern
  payload: AnyValue.from(result),
};
```

### 4. Complex Return Types
```typescript
// ❌ NEVER DO THIS
return {
  status: 'success',
  data: result,
  timestamp: Date.now(),
  requestId: req.requestId,
};
```

## Testing Best Practices

**Recommended Approach:**
- Create offline node
- Add service to be tested + all dependent services
- Call action through node API (proper context, can call other actions)
- Fast, lightweight, real integration tests

**Alternative (Mock-based unit tests also possible but not recommended):**
```typescript
describe('myAction', () => {
  it('should process string input correctly', async () => {
    const payload = AnyValue.from('test input');
    const context = createMockContext();
    const result = await myAction(payload, context);
    expect(result.ok).toBe(true);
    if (result.ok) {
      const output = result.value.as<string>();
      expect(output.ok).toBe(true);
      expect(output.value).toBe('processed: test input');
    }
  });
});
```

## Key Takeaways

1. **Single Path**: Expect exact types, fail on mismatch
2. **Clean Handlers**: Business logic only, no infrastructure concerns
3. **Framework Trust**: Trust framework for serialization, networking, IDs
4. **Type Safety**: Use specific types, never `unknown`
5. **Error Clarity**: Return descriptive error messages
6. **API Alignment**: Match Rust signatures exactly
7. **No Fallbacks**: Predictable, deterministic execution paths

## Debugging

- **Type Mismatches**: Check `AnyValue.as<T>()` calls
- **Serialization Issues**: Framework handles this - don't touch bytes manually
- **Network Errors**: Check service registration and paths
- **Handler Not Called**: Verify action registration succeeded
