#!/usr/bin/env bun
/**
 * Build script to generate encrypted companion types from decorators
 * This eliminates the need for 'any' types in the decorator system
 */

import * as ts from 'typescript';
import * as fs from 'fs';
import * as path from 'path';

interface FieldInfo {
  name: string;
  type: string;
  label?: string;
}

interface ClassInfo {
  name: string;
  fields: FieldInfo[];
}

function analyzeSourceFile(filePath: string): ClassInfo[] {
  const sourceCode = fs.readFileSync(filePath, 'utf-8');
  const sourceFile = ts.createSourceFile(filePath, sourceCode, ts.ScriptTarget.Latest, true);

  const classes: ClassInfo[] = [];

  function visit(node: ts.Node) {
    if (ts.isClassDeclaration(node) && node.name) {
      const className = node.name.text;
      const fields: FieldInfo[] = [];

      // Check for @Encrypt decorator (TypeScript 5 syntax)
      const hasEncryptDecorator = node.modifiers?.some(modifier => {
        if (ts.isDecorator(modifier)) {
          // Check if it's a call expression (e.g., @Encrypt())
          if (ts.isCallExpression(modifier.expression)) {
            const expression = modifier.expression.expression;
            if (ts.isIdentifier(expression) && expression.text === 'Encrypt') {
              return true;
            }
          }
          // Check if it's a direct identifier (e.g., @Encrypt)
          else if (ts.isIdentifier(modifier.expression) && modifier.expression.text === 'Encrypt') {
            return true;
          }
        }
        return false;
      });

      if (hasEncryptDecorator) {
        console.log(`Found @Encrypt class: ${className}`);

        // Extract field information
        node.members.forEach(member => {
          if (ts.isPropertyDeclaration(member) && member.name && ts.isIdentifier(member.name)) {
            const fieldName = member.name.text;
            const fieldType = member.type ? member.type.getText() : 'string';

            // Check for @runar decorator (TypeScript 5 syntax)
            const runarDecorator = member.modifiers?.find(modifier => {
              if (ts.isDecorator(modifier)) {
                if (ts.isCallExpression(modifier.expression)) {
                  const expression = modifier.expression.expression;
                  if (ts.isIdentifier(expression) && expression.text === 'runar') {
                    return true;
                  }
                }
              }
              return false;
            });

            let label: string | undefined;
            if (
              runarDecorator &&
              ts.isDecorator(runarDecorator) &&
              ts.isCallExpression(runarDecorator.expression)
            ) {
              const args = runarDecorator.expression.arguments;
              if (args.length > 0 && ts.isStringLiteral(args[0])) {
                label = args[0].text;
                console.log(`  Found @runar('${label}') field: ${fieldName}`);
              }
            } else {
              console.log(`  Found plain field: ${fieldName}`);
            }

            fields.push({ name: fieldName, type: fieldType, label });
          }
        });

        classes.push({ name: className, fields });
      }
    }

    ts.forEachChild(node, visit);
  }

  visit(sourceFile);
  return classes;
}

function generateTypeDefinitions(classes: ClassInfo[]): string {
  let output = '// Generated types - do not edit manually\n';
  output += '// This file is automatically generated by the build script\n\n';

  for (const classInfo of classes) {
    const encryptedClassName = `Encrypted${classInfo.name}`;
    output += `export interface ${encryptedClassName} {\n`;

    for (const field of classInfo.fields) {
      if (field.label) {
        // This is an encrypted field
        output += `  ${field.label}_encrypted: string;\n`;
      } else {
        // This is a plain field
        output += `  ${field.name}: ${field.type};\n`;
      }
    }

    output += '}\n\n';
  }

  return output;
}

function main() {
  console.log('üîç Analyzing source files for @Encrypt decorators...\n');

  const sourceFiles = [
    'test/anyvalue_struct_encryption.test.ts'
  ];

  const allClasses: ClassInfo[] = [];

  for (const sourceFile of sourceFiles) {
    if (fs.existsSync(sourceFile)) {
      console.log(`üìÅ Analyzing: ${sourceFile}`);
      const classes = analyzeSourceFile(sourceFile);
      allClasses.push(...classes);
      console.log('');
    } else {
      console.log(`‚ùå File not found: ${sourceFile}`);
    }
  }

  if (allClasses.length === 0) {
    console.log('‚ùå No @Encrypt classes found');
    return;
  }

  console.log('üìù Generating type definitions...\n');

  const generatedTypes = generateTypeDefinitions(allClasses);

  // Write to generated-types.ts
  const outputPath = 'src/generated-types.ts';
  fs.writeFileSync(outputPath, generatedTypes);

  console.log(`‚úÖ Generated types written to: ${outputPath}`);
  console.log('\nüìÑ Generated content:');
  console.log('‚îÄ'.repeat(50));
  console.log(generatedTypes);
  console.log('‚îÄ'.repeat(50));

  console.log('\nüéâ Build-time type generation complete!');
  console.log('Now you can import and use the generated types without any "any" types!');
}

// Run the build script
main();
