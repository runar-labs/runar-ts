#!/usr/bin/env bun
/**
 * Build script to generate encrypted companion types from decorators
 * This eliminates the need for 'any' types in the decorator system
 */

import * as ts from 'typescript';
import * as fs from 'fs';
import * as path from 'path';

interface FieldInfo {
  name: string;
  type: string;
  label?: string;
}

interface ClassInfo {
  name: string;
  fields: FieldInfo[];
}

function analyzeSourceFile(filePath: string): ClassInfo[] {
  const sourceCode = fs.readFileSync(filePath, 'utf-8');
  const sourceFile = ts.createSourceFile(filePath, sourceCode, ts.ScriptTarget.Latest, true);

  const classes: ClassInfo[] = [];

  function visit(node: ts.Node) {
    if (ts.isClassDeclaration(node) && node.name) {
      const className = node.name.text;
      const fields: FieldInfo[] = [];

      // Check for @Encrypt decorator (TypeScript 5 syntax)
      const hasEncryptDecorator = node.modifiers?.some(modifier => {
        if (ts.isDecorator(modifier)) {
          // Check if it's a call expression (e.g., @Encrypt())
          if (ts.isCallExpression(modifier.expression)) {
            const expression = modifier.expression.expression;
            if (ts.isIdentifier(expression) && expression.text === 'Encrypt') {
              return true;
            }
          }
          // Check if it's a direct identifier (e.g., @Encrypt)
          else if (ts.isIdentifier(modifier.expression) && modifier.expression.text === 'Encrypt') {
            return true;
          }
        }
        return false;
      });

      if (hasEncryptDecorator) {
        console.log(`Found @Encrypt class: ${className}`);

        // Extract field information
        node.members.forEach(member => {
          if (ts.isPropertyDeclaration(member) && member.name && ts.isIdentifier(member.name)) {
            const fieldName = member.name.text;
            const fieldType = member.type ? member.type.getText() : 'string';

            // Check for @runar decorator (TypeScript 5 syntax)
            const runarDecorator = member.modifiers?.find(modifier => {
              if (ts.isDecorator(modifier)) {
                if (ts.isCallExpression(modifier.expression)) {
                  const expression = modifier.expression.expression;
                  if (ts.isIdentifier(expression) && expression.text === 'runar') {
                    return true;
                  }
                }
              }
              return false;
            });

            let labels: string[] | undefined;
            if (
              runarDecorator &&
              ts.isDecorator(runarDecorator) &&
              ts.isCallExpression(runarDecorator.expression)
            ) {
              const args = runarDecorator.expression.arguments;
              if (args.length > 0) {
                if (ts.isStringLiteral(args[0])) {
                  // Single string label: @runar('label')
                  labels = [args[0].text];
                  console.log(`  Found @runar('${args[0].text}') field: ${fieldName}`);
                } else if (ts.isArrayLiteralExpression(args[0])) {
                  // Array of labels: @runar(['label1', 'label2'])
                  labels = args[0].elements
                    .filter(element => ts.isStringLiteral(element))
                    .map(element => (element as ts.StringLiteral).text);
                  console.log(`  Found @runar([${labels.join(', ')}]) field: ${fieldName}`);
                }
              }
            } else {
              console.log(`  Found plain field: ${fieldName}`);
            }

            fields.push({ name: fieldName, type: fieldType, label: labels?.[0] });
          }
        });

        classes.push({ name: className, fields });
      }
    }

    ts.forEachChild(node, visit);
  }

  visit(sourceFile);
  return classes;
}

function generateTypeDefinitions(classes: ClassInfo[]): string {
  let output = '// Generated types - do not edit manually\n';
  output += '// This file is automatically generated by the build script\n\n';
  output += "import { EncryptedLabelGroup } from 'runar-ts-serializer/src/encryption';\n";
  output += "import { type RunarEncryptable } from './index';\n";

  // Import the original classes
  for (const classInfo of classes) {
    output += `import { ${classInfo.name} } from '../test_fixtures/dist/test_fixtures/test_fixtures';\n`;
  }
  output += '\n';

  for (const classInfo of classes) {
    const encryptedClassName = `Encrypted${classInfo.name}`;

    // Collect unique labels and plain fields
    const uniqueLabels = new Set<string>();
    const plainFields = new Set<string>();
    const nestedEncryptedFields = new Map<string, { type: string; isNullable: boolean }>();

    for (const field of classInfo.fields) {
      if (field.label) {
        // Check if this is a nested encrypted object (contains | null and is an object type)
        if (
          field.type.includes('| null') &&
          (field.type.includes('Profile') || field.type.includes('Metadata'))
        ) {
          const isNullable = field.type.includes('| null');
          const baseType = field.type.replace(' | null', '').trim();
          nestedEncryptedFields.set(field.name, { type: baseType, isNullable });
        } else {
          // This is a primitive field with a label - add to unique labels
          uniqueLabels.add(field.label);
        }
      } else {
        plainFields.add(field.name);
      }
    }

    // Generate the encrypted interface that extends RunarEncryptable
    output += `export interface ${encryptedClassName} extends RunarEncryptable<${classInfo.name}, ${encryptedClassName}> {\n`;

    // Add encrypted fields (one per unique label)
    for (const label of uniqueLabels) {
      output += `  ${label}_encrypted: EncryptedLabelGroup;\n`;
    }

    // Add nested encrypted object fields
    for (const [fieldName, fieldInfo] of nestedEncryptedFields) {
      const encryptedType = `Encrypted${fieldInfo.type}`;
      const nullableSuffix = fieldInfo.isNullable ? ' | null' : '';
      output += `  ${fieldName}: ${encryptedType}${nullableSuffix};\n`;
    }

    // Add plain fields
    for (const fieldName of plainFields) {
      const field = classInfo.fields.find(f => f.name === fieldName);
      output += `  ${fieldName}: ${field?.type || 'string'};\n`;
    }

    output += '}\n\n';
  }

  return output;
}

function main() {
  console.log('üîç Analyzing source files for @Encrypt decorators...\n');

  const sourceFiles = ['../test_fixtures/test_fixtures.ts'];

  const allClasses: ClassInfo[] = [];

  for (const sourceFile of sourceFiles) {
    if (fs.existsSync(sourceFile)) {
      console.log(`üìÅ Analyzing: ${sourceFile}`);
      const classes = analyzeSourceFile(sourceFile);
      allClasses.push(...classes);
      console.log('');
    } else {
      console.log(`‚ùå File not found: ${sourceFile}`);
    }
  }

  if (allClasses.length === 0) {
    console.log('‚ùå No @Encrypt classes found');
    return;
  }

  console.log('üìù Generating type definitions...\n');

  const generatedTypes = generateTypeDefinitions(allClasses);

  // Write to encrypted-types.ts
  const outputPath = '../src/encrypted-types.ts';
  fs.writeFileSync(outputPath, generatedTypes);

  console.log(`‚úÖ Generated types written to: ${outputPath}`);
  console.log('\nüìÑ Generated content:');
  console.log('‚îÄ'.repeat(50));
  console.log(generatedTypes);
  console.log('‚îÄ'.repeat(50));

  console.log('\nüéâ Build-time type generation complete!');
}

// Run the build script
main();
